ðŸ§  1. Basic Building Blocks

Most complex queries are built using:

Q objects â†’ for OR, AND, NOT conditions

F expressions â†’ for comparing fields with each other

annotate() and aggregate() â†’ for aggregations

Subquery and OuterRef â†’ for nested queries

select_related() and prefetch_related() â†’ for query optimization

values() and values_list() â†’ for dictionary or tuple results

âš™ï¸ 2. Using Q objects (Complex Filtering)
from django.db.models import Q
from home.models import Student

# Students with marks > 80 OR name starts with 'A'
students = Student.objects.filter(Q(marks__gt=80) | Q(name__startswith='A'))

# Students with marks > 80 AND not named 'Ali'
students = Student.objects.filter(Q(marks__gt=80) & ~Q(name='Ali'))


ðŸ‘‰ Q objects let you combine filters using | (OR), & (AND), and ~ (NOT) â€” similar to SQL logic.

âš–ï¸ 3. Using F expressions (Field-to-Field Comparison)
from django.db.models import F
from home.models import Employee

# Employees where bonus is greater than salary
Employee.objects.filter(bonus__gt=F('salary'))

# Increase all employeesâ€™ salary by 10%
Employee.objects.update(salary=F('salary') * 1.10)


ðŸ‘‰ F lets you compare or update using field values, not constants.

ðŸ“Š 4. Aggregation and Annotation
from django.db.models import Avg, Count, Sum, Max, Min
from home.models import Order

# Average order price
Order.objects.aggregate(Avg('price'))

# Count orders per customer
Order.objects.values('customer__name').annotate(order_count=Count('id'))

# Total revenue per month
Order.objects.annotate(total=Sum('price'))


ðŸ‘‰ annotate() adds a computed field to each record,
aggregate() returns a summary dictionary.

ðŸ” 5. Subquery and OuterRef (Nested Queries)
from django.db.models import Subquery, OuterRef
from home.models import Student, Exam

latest_exam = Exam.objects.filter(student=OuterRef('pk')).order_by('-date')

# Attach latest exam score for each student
Student.objects.annotate(latest_score=Subquery(latest_exam.values('score')[:1]))


ðŸ‘‰ Similar to a SQL subquery â€” used when you need data from related tables dynamically.

ðŸš€ 6. select_related() vs prefetch_related()
# select_related â†’ for ForeignKey (joins in one query)
students = Student.objects.select_related('school').all()

# prefetch_related â†’ for ManyToMany or reverse ForeignKey
students = Student.objects.prefetch_related('courses').all()


ðŸ‘‰ Reduces the number of SQL queries â€” improves performance.

ðŸ§® 7. Complex chaining

You can chain all these together:

Student.objects.filter(
    Q(marks__gte=70) | Q(grade='A'),
    school__city='Lahore'
).annotate(
    total_marks=F('marks') + F('bonus')
).filter(
    total_marks__gt=90
)

ðŸ§© 8. Raw SQL (when ORM canâ€™t handle it)
Student.objects.raw('SELECT * FROM home_student WHERE marks > %s', [80])


ðŸ‘‰ Use sparingly â€” ORM handles most cases cleanly.

ðŸ’¡ Example (Real Case)

Find all authors who have written more than 3 published books and have average rating > 4.5:

from django.db.models import Count, Avg

Author.objects.annotate(
    total_books=Count('book'),
    avg_rating=Avg('book__rating')
).filter(
    total_books__gt=3,
    avg_rating__gt=4.5
)
