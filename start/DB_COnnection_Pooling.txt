üíß What Is Database Connection Pooling?
Connection pooling means reusing existing database connections instead of opening a new one every time your application needs to talk to the database.
üß† Without Pooling (Default Django behavior)
Each time a web request hits your Django app:
Django opens a new database connection.
Executes queries.
Closes the connection.
‚ö†Ô∏è Problem:
Opening/closing a DB connection is expensive (takes time and CPU).
If your app gets 1000 requests per second, that‚Äôs 1000 open/close cycles per second.
This leads to slow performance and too many database connections.
üöÄ With Connection Pooling
Instead of creating new connections all the time, Django (or a pooling layer like PgBouncer) keeps a pool ‚Äî a ready-to-use set of open database connections.
When a request comes in:
Django borrows a connection from the pool.
Executes the query.
Returns it to the pool when done.
If another request arrives, it just reuses that same connection.
üß© Analogy
Think of it like a car rental service:
‚ùå Without pooling: You buy a new car for every trip, then destroy it.
‚úÖ With pooling: You keep a fleet of cars and reuse them for each trip.

| Benefit                 | Description                                                   |
| ----------------------- | ------------------------------------------------------------- |
| ‚ö° **Performance**       | Avoids the overhead of creating new DB connections each time. |
| üß† **Scalability**      | Can handle more concurrent requests efficiently.              |
| üß© **Resource control** | Limits how many connections your app can open to the DB.      |
| üîí **Stability**        | Prevents ‚Äútoo many connections‚Äù errors under load.            |

Example:
DATABASES = {
    'default': {
        'ENGINE': 'django_db_geventpool.backends.postgresql_psycopg2',
        'NAME': 'mydb',
        'USER': 'postgres',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '5432',
        'OPTIONS': {
            'MAX_CONNS': 20,
            'REUSE_CONNS': 10,
        }
    }
}
Here:
MAX_CONNS = max total connections in pool.
REUSE_CONNS = how many idle connections are kept for reuse.

üßæ In Short
Connection pooling = caching database connections for reuse
‚Üí fewer connection setups
‚Üí faster response times
‚Üí less database strain

__________________________________________________________________________________________________________________________________________________________________________
üß† 1. Understanding Database Connections in Django
By default, Django does NOT use connection pooling ‚Äî each web request opens a database connection when needed and closes it after the request ends (depending on CONN_MAX_AGE).
Default connection behavior:
CONN_MAX_AGE = 0 ‚Üí Django closes DB connections after each request.
CONN_MAX_AGE = None ‚Üí Persistent connections (never close).
CONN_MAX_AGE = 60 ‚Üí Keep connections alive for 60 seconds (recommended middle ground).
Example in settings.py:
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": "mydb",
        "USER": "postgres",
        "PASSWORD": "password",
        "HOST": "localhost",
        "PORT": "5432",
        "CONN_MAX_AGE": 60,  # ‚úÖ keep connection alive for 60s
    }
}
‚öôÔ∏è 2. Enabling True Connection Pooling (with django-db-geventpool or sqlalchemy)
Django itself doesn‚Äôt include a connection pooler, but you can add one using libraries or external tools.
Option 1: ‚úÖ django-db-geventpool (pure Django)
A simple, drop-in connection pool for PostgreSQL/MySQL.
Install:
pip install django-db-geventpool
Update settings.py:
DATABASES = {
    'default': {
        'ENGINE': 'django_db_geventpool.backends.postgresql_psycopg2',
        'NAME': 'mydb',
        'USER': 'postgres',
        'PASSWORD': 'password',
        'HOST': 'localhost',
        'PORT': '5432',
        'CONN_MAX_AGE': 0,
        'OPTIONS': {
            'MAX_CONNS': 20,  # max number of connections in pool
            'REUSE_CONNS': 10,  # how many to keep idle for reuse
        }
    }
}

Option 2: üß© Use PgBouncer (recommended for production)
PgBouncer is a lightweight PostgreSQL connection pooler that sits between Django and PostgreSQL.
Steps:
Install and run PgBouncer.
Configure Django to connect to PgBouncer instead of PostgreSQL directly:
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'HOST': '127.0.0.1',
        'PORT': '6432',  # PgBouncer port
        'NAME': 'mydb',
        'USER': 'postgres',
        'PASSWORD': 'password',
    }
}
PgBouncer manages pooling, reducing connection overhead.


Connection pool¬∂
New in Django 5.1.
To use a connection pool with psycopg, you can either set "pool" in the OPTIONS part of your database configuration in DATABASES to be a dict to be passed to ConnectionPool, or to True to use the ConnectionPool defaults:

DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        # ...
        "OPTIONS": {
            "pool": True,
        },
    },
}
This option requires psycopg[pool] or psycopg-pool to be installed and is ignored with psycopg2.




Connecting to the database¬∂
Refer to the settings documentation.

Connection settings are used in this order:

OPTIONS.

NAME, USER, PASSWORD, HOST, PORT

MySQL option files.

In other words, if you set the name of the database in OPTIONS, this will take precedence over NAME, which would override anything in a MySQL option file.

Here‚Äôs a sample configuration which uses a MySQL option file:

# settings.py
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.mysql",
        "OPTIONS": {
            "read_default_file": "/path/to/my.cnf",
        },
    }
}
# my.cnf
[client]
database = NAME
user = USER
password = PASSWORD
default-character-set = utf8mb4


Setting sql_mode¬∂
The default value of the sql_mode option contains STRICT_TRANS_TABLES. That option escalates warnings into errors when data are truncated upon insertion, so Django highly recommends activating a strict mode for MySQL to prevent data loss (either STRICT_TRANS_TABLES or STRICT_ALL_TABLES).

If you need to customize the SQL mode, you can set the sql_mode variable like other MySQL options: either in a config file or with the entry 'init_command': "SET sql_mode='STRICT_TRANS_TABLES'" in the OPTIONS part of your database configuration in DATABASES.

Isolation level¬∂
When running concurrent loads, database transactions from different sessions (say, separate threads handling different requests) may interact with each other. These interactions are affected by each session‚Äôs transaction isolation level. You can set a connection‚Äôs isolation level with an 'isolation_level' entry in the OPTIONS part of your database configuration in DATABASES. Valid values for this entry are the four standard isolation levels:

'read uncommitted'

'read committed'

'repeatable read'

'serializable'