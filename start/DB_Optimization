Excellent — this is a core topic for scaling Django applications.
Let’s go over how to optimize database access in Django step by step, with practical code examples and best practices.

⚙️ 1. Understanding ORM Queries

Every ORM operation like .all(), .filter(), .get(), .exclude() etc. generates SQL.
You must avoid unnecessary database hits — Django ORM is lazy, so queries are only executed when data is actually used.

Example:

qs = Book.objects.all()  # No query yet
books = list(qs)         # Query runs here

🚀 2. Use select_related() for ForeignKeys

Use when you have one-to-one or foreign key relationships.

Without optimization:

for book in Book.objects.all():
    print(book.author.name)  # One query per book (N+1 problem)


Optimized:

for book in Book.objects.select_related('author'):
    print(book.author.name)  # Single JOIN query

⚡ 3. Use prefetch_related() for Many-to-Many or Reverse FKs

Use when dealing with many-to-many or reverse foreign key relations.

Without optimization:

for author in Author.objects.all():
    print([book.title for book in author.book_set.all()])  # N+1 queries


Optimized:

for author in Author.objects.prefetch_related('book_set'):
    print([book.title for book in author.book_set.all()])  # Two total queries

🧠 4. Use only() or defer() to Limit Columns

Load only the fields you need.

Book.objects.only('title', 'price')  # Loads only these columns
Book.objects.defer('description')   # Loads all except description

📊 5. Use values() or values_list() for Raw Dictionaries/Tuples

Avoid creating model instances when you just need certain fields.

Book.objects.values('id', 'title')
Book.objects.values_list('title', flat=True)

🧩 6. Use annotate() and aggregate() for Computations in DB

Let the database do counting/summing work instead of Python loops.

from django.db.models import Count, Avg

Author.objects.annotate(num_books=Count('book'))
Book.objects.aggregate(average_price=Avg('price'))

🧰 7. Use QuerySet Caching Properly

A queryset is cached after the first evaluation:

qs = Book.objects.all()
print(qs.count())  # Query 1
print(list(qs))    # Reuses cache, no second query


⚠️ But chaining queries (e.g. qs.filter(...)) invalidates cache and triggers new queries.

⚖️ 8. Batch Inserts and Updates

Use bulk operations:

Book.objects.bulk_create([
    Book(title='A'), Book(title='B')
])
Book.objects.bulk_update(books, ['price'])

🧹 9. Avoid Query Inside Loops

Bad:

for user in User.objects.all():
    user.profile  # hits DB each iteration


Good:

for user in User.objects.select_related('profile'):
    user.profile

🔍 10. Use exists() Instead of count() for Existence Check
if User.objects.filter(email='test@example.com').exists():
    ...


→ Faster than .count() > 0

🗄️ 11. Use Database Indexes

Add indexes on fields you query often.

class Book(models.Model):
    title = models.CharField(max_length=200, db_index=True)


You can also add multi-column indexes:

class Meta:
    indexes = [
        models.Index(fields=['title', 'author']),
    ]

🧾 12. Use queryset.explain() to Inspect SQL Plan

You can analyze query performance directly:

Book.objects.filter(price__gt=100).explain()

💡 13. Use Caching for Heavy Queries

Integrate Redis or Memcached for caching:

from django.core.cache import cache

books = cache.get('books')
if not books:
    books = list(Book.objects.all())
    cache.set('books', books, 300)

🧩 14. Use Raw SQL When Needed

When ORM isn’t efficient enough:

Book.objects.raw('SELECT * FROM book WHERE price > %s', [100])

🔎 15. Profile Your Queries

Enable query logging:

from django.db import connection
print(connection.queries)


Or use packages:

django-debug-toolbar

django-silk